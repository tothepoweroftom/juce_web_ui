#pragma once

namespace webui
{
namespace BrowserIntegration
{
    BrowserIntegrationPluginClient::BrowserIntegrationPluginClient (BrowserIntegration& b,
                                                                    juce::AudioProcessorValueTreeState& p,
                                                                    juce::String f,
                                                                    juce::String c)
        : BrowserIntegrationClient (c, b),
          parameterValueTree (p),
          valueTreeSynchroniser (p.state, "PARAMETERS", b),
          pluginEditorSourceFile (f)
    {
    }

    // This is a separate method rather than called from the constructor because it needs
    // to be called after all the members of the class implementing it have been setup
    void BrowserIntegrationPluginClient::setupBrowserPluginIntegration()
    {
        registerBrowserCallback ("init", [this] (juce::var) {
            sendParameterMetadata();
            valueTreeSynchroniser.sendFullSyncCallback();
        });

        registerBrowserCallback ("setParameter", [this] (juce::var data) {
            parameterValueTree.getParameterAsValue (data["id"].toString()).setValue (data["value"]);
        });
    }

    void BrowserIntegrationPluginClient::sendParameterMetadata()
    {
        juce::Array<juce::var> parameterInfos;

        for (auto parameterState: parameterValueTree.state)
        {
            auto id = parameterState.getProperty ("id").toString();
            auto rangedParameter = parameterValueTree.getParameter (id);

            auto* parameterInfo = new juce::DynamicObject();
            parameterInfo->setProperty ("id", id);

            if (auto floatParameter = dynamic_cast<juce::AudioParameterFloat*> (rangedParameter))
            {
                parameterInfo->setProperty ("type", "float");
                parameterInfo->setProperty ("label", floatParameter->label);
                parameterInfo->setProperty ("min", floatParameter->range.start);
                parameterInfo->setProperty ("max", floatParameter->range.end);
                parameterInfo->setProperty ("step", floatParameter->range.interval);
            }
            else if (auto intParameter = dynamic_cast<juce::AudioParameterInt*> (rangedParameter))
            {
                parameterInfo->setProperty ("type", "int");
                parameterInfo->setProperty ("label", intParameter->label);
                parameterInfo->setProperty ("min", intParameter->getRange().getStart());
                parameterInfo->setProperty ("max", intParameter->getRange().getEnd());
                parameterInfo->setProperty ("step", 1);
            }
            else if (auto boolParameter = dynamic_cast<juce::AudioParameterBool*> (rangedParameter))
            {
                parameterInfo->setProperty ("type", "bool");
                parameterInfo->setProperty ("label", boolParameter->label);
            }
            else if (auto choiceParameter = dynamic_cast<juce::AudioParameterChoice*> (rangedParameter))
            {
                parameterInfo->setProperty ("type", "choice");
                parameterInfo->setProperty ("choices", choiceParameter->choices);
                parameterInfo->setProperty ("label", choiceParameter->label);
            }

            parameterInfos.add (juce::var (parameterInfo));
        }

        sendEventToBrowser ("parameterMetadata", parameterInfos);

#if JUCE_DEBUG && BROWSER_INTEGRATION_WRITE_PARAMETER_CONFIG_IN_DEBUG && !(JUCE_IOS || JUCE_ANDROID)
        writeParameterConfigForTs (parameterInfos);
#endif
    }

    void BrowserIntegrationPluginClient::writeParameterConfigForTs (juce::Array<juce::var> parameterInfos)
    {
        juce::StringArray parameterIds;

        juce::String output = R"(// This file is autogenerated by the JUCE BrowserIntegrationPluginClient class,
// by inspecting all the parameters in the AudioProcessorValueTreeState.
//
// It is updated whenever you run the app in debug mode with the macro
// BROWSER_INTEGRATION_WRITE_PARAMETER_CONFIG_IN_DEBUG=1.
//
// You shouldn't need to edit this manually - if you add a new parameter,
// running the app in debug mode should be enough to update this.
        
import { ParameterModel } from "../../juceIntegration/models/ParameterModel";

export type ParametersType = {
)";

        for (auto parameterInfo: parameterInfos)
        {
            parameterIds.add ("\"" + parameterInfo["id"].toString() + "\"");

            juce::String type = "number";
            if (parameterInfo["type"] == "bool")
                type = "boolean";
            else if (parameterInfo["type"] == "choice")
            {
                juce::StringArray choiceTypes;
                for (auto choice: *(parameterInfo["choices"].getArray()))
                    choiceTypes.add ("\"" + choice.toString() + "\"");

                type = choiceTypes.joinIntoString (" | ");
            }

            output += "  " + parameterInfo["id"].toString() + ": ParameterModel<" + type + ">;\n";
        }

        output += R"(};
        
export const PARAMETER_IDS = [
  )" + parameterIds.joinIntoString (",\n  ")
                  + ",\n];\n";

        juce::File tsFile (pluginEditorSourceFile
                               .getParentDirectory()
                               .getParentDirectory()
                               .getChildFile ("ui")
                               .getChildFile ("src")
                               .getChildFile ("config")
                               .getChildFile ("autogenerated")
                               .getChildFile ("parameters.ts"));

        jassert (tsFile.existsAsFile());

        tsFile.replaceWithText (output);

        DBG ("Parmeter types writen to parameters.ts");
    }
}
}
